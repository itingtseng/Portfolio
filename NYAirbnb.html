<!DOCTYPE html>
<meta charset="utf-8">
<html>

<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112852518-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-112852518-2');
</script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script type="text/javascript" src="https://d3js.org/topojson.v2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.0/d3-legend.js"></script>
    <script src="d3-legend.min.js"></script>
    <meta charset="utf-8">
    <title>Airbnb New York 2019</title>
    <style type="text/css">
    #boroughs {
        stroke: none;
        stroke-width: 0px;
        fill: green;
        opacity: .9;
        position: absolute;
        top: 0;
        left: 0;
    }

    #routes {
        stroke: gray;
        stroke-width: 2;
        fill: none;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 100;
    }

    #stations {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 150;
        fill: #333;
    }

    .zoom {
        cursor: move;
        fill: none;
        pointer-events: all;
    }

    .axis {
        stroke-width: 0.5px;
        stroke: #888;
        font: 10px avenir next, sans-serif;
    }

    .axis>path {
        stroke: #888;
    }

    body {
        font-size: 14px;
        font-family: 'Open Sans', sans-serif;
        font-weight: 400;
        text-align: center;
    }

    label {
        font-size: 14px;
    }

    #title {
        font-size: 36px;
        padding-bottom: 20px;
        padding-top: 20px;
        font-weight: 300;
    }

    #explanation {
        font-size: 16px;
        max-width: 960px;
        margin: 0 auto;
        padding-top: 10px;
        color: #484848;
        font-weight: 300;
        text-align: left;
    }

    #tooltip {
        position: absolute;
        width: 300px;
        height: auto;
        padding: 10px;
        background-color: white;
        -webkit-border-radius: 10px;
        -moz-border-radius: 10px;
        border-radius: 10px;
        -webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        -moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        pointer-events: none;
    }

    #tooltip.hidden {
        display: none;
    }

    #tooltip p {
        margin: 0;
        font-family: sans-serif;
        font-size: 16px;
        line-height: 20px;
        text-align: left;
        font-family: 'Open Sans', sans-serif;
    }
    </style>
</head>

<body>
    <div id="tooltip" class="hidden">
        <p>Name : <strong id="name"></strong><br><br></p>
        <p>Host Name : <span id="host_name"></span></p>
        <p>Region : <span id="neighbourhood_group"></span></p>
        <p>Type : <span id="room_type"></span></p>
        <p>Price : <span id="price"></span></p>
        <p>Minimum Nights : <span id="minimum_nights"></span></p>
        <p>Number of Reviews : <span id="number_of_reviews"></span></p>
        <p>Last Review Time : <span id="review_time"></span></p>
        <p>Host Listings Count : <span id="calculated_host_listings_count"></span></p>
        <p>Availability in a Year : <span id="availability_365"></span></p>
    </div>
    <div id="title">New York City Airbnb in 2019</div>
    <!-- Button -->
    <!-- Button -->
    <div style="float: left; padding-left: 50px; text-align: right; padding-bottom: 50px">
        <div><label style="line-height:50px; vertical-align: top"><b>Map</b></label></div>
        <div><svg id="svg1"></svg></div>
    </div>
    <div style="float: left; padding-left: 50px; text-align: left; padding-bottom: 50px">
        <div><label style="line-height:50px; vertical-align: top"><b>Filters</b></label></div>
        <form style="line-height:30px">
            <input id="check1" type="checkbox" class="checkbox" value="Bronx" checked><label>Bronx</label>
            <input id="check2" type="checkbox" class="checkbox" value="Brooklyn" checked><label>Brooklyn</label>
            <input id="check3" type="checkbox" class="checkbox" value="Manhattan" checked><label>Manhattan</label>
            <input id="check4" type="checkbox" class="checkbox" value="Queens" checked><label>Queens</label>
            <input id="check5" type="checkbox" class="checkbox" value="Staten Island" checked><label>Staten Island</label>
        </form>
        <!-- Button -->
        <form style="line-height:30px" id="room">
            <input type="radio" name="filterPreset" id="Entire" checked><label>Entire home/apt</label>
            <input type="radio" name="filterPreset" id="Private"><label>Private room</label>
            <input type="radio" name="filterPreset" id="Shared"><label>Shared room</label>
        </form>
        <form style="line-height:30px">
            <label for="input_year" style="text-align: left">
                Year = <span id="input_year-value"></span>
            </label>
            <input type="range" min="2011" max="2019" id="input_year">
        </form>
        <div><label style="line-height:50px; vertical-align: top"><b>Legend</b></label></div>
        <div id="legend1"><label style="line-height:50px; vertical-align: top">Number of Reviews&nbsp&nbsp&nbsp&nbsp&nbsp</label></div>
        <div id="legend2"><label style="line-height:50px; vertical-align: top">Calculated Host Listings Count</label></div>
        <div id="legend3"><label style="line-height:50px; vertical-align: top">Map Legend</label></div>
        <div><label style="line-height:50px; vertical-align: top"><b>Brushable Histogram</b></label></div>
        <div id="totalDistance"><svg id="svg2"></svg></div>
    </div>
    <div id="explanation">
        <h4>YouTube video</h4>
        <a href="https://youtu.be/Pou7nx0tKpk">New York City Airbnb Open Data</a><br><br>
        <h1>Description</h1>
        Since 2008, guests and hosts have used Airbnb to expand on traveling possibilities and present more unique, personalized way of experiencing the world. This dataset describes the listing activity and metrics in NYC, NY for 2019.<br><br>
        This data file includes all needed information to find out more about hosts, geographical availability, necessary metrics to make predictions and draw conclusions.<br><br>
        <h4>Dataset</h4>
        <a href="https://www.kaggle.com/dgomonov/new-york-city-airbnb-open-data/data">New York City Airbnb Open Data</a><br><br>
        <h1>Research</h1>
        <h2>How do we clean up these chunk data? How do we display it in batches?</h2>After we downloaded this New York City Airbnb Open Data, the first thing that came to our mind is how to deal with this bulk dataset? There are almost fifty thousand data in this data file. So first of all, we tried to answer this question by checking that: is there any time data in the columns that we can use it as a filter? Then we found the last review information. We also found out that much data is without last review information and the number of reviews information. Therefore we removed these data. By doing so, we almost eliminated ten thousand data.<br><br> 
         <h2>Is there any noticeable difference in traffic among different areas, and what could be the reason for it?</h2>We used the latitude and longitude coordinates to generate geo JSON data and put them on the New York City map. To answer this question, we also have to point out the subway lines and stations of New York City. Besides, since there are so many points clustering in Manhattan and Brooklyn, we designed the zooming and panning function for us to view the map on a large scale map to depict a small territory. You can see that in the area which is densely populated, the Airbnb distribution has highly related to the subway stations. But outside the egg yolk area, this trend is not so obvious. We can generalize that maybe it is because of the traffic issue or the number of parking spaces. In the metropolitan area, driving is the main problem for people who are not local. And this population also is the one who has a high demand for Airbnb. Moreover, finding a parking space could deter many people from driving downtown. In summary, people who live downtown have to rely on public transportation. Therefore Airbnb in the metropolitan area has to provide its customers geo-advantage of transport.<br><br> 
         <h2>What can we learn from predictions? (ex: locations, prices, reviews, etc.)</h2>
        <h3>Years (Last Review)</h3>The data we use to filter different years is the last review information. We can see that the newest data for the last review is July 8, 2019, and this is over half of the year. If the last review time stops from 2018 or the years before, we could have a hypothesis that this Airbnb is permanently closed. Hence by displaying the Airbnb location on the map with different last review times, we can filter Airbnb, which is out of business in each since 2011. As a result of that, our final displayed Airbnbs in 2019 are twenty-five thousand data, which is almost half the number of our initial data file. You can use the slider bar to see the permanently closed Airbnb every year for 2011 to 2018.<br><br>
         <h3>Room Types</h3>We can check three different Airbnb room types in this data file: entire home or apartment, private room, and shared room. There is no distinguish spacial distribution for Airbnb room types in 2019.  This room types attribute also serves as a partitioned data set function. We designed this radio button for displaying data in batches. As we can see here the entire home or apartment and private room are half and half.<br><br> 
         <h3>Regions</h3> The reason that we designed the checkbox for different regions is because, during our design process, we had considered consulting the real Airbnb website and designed something with a similar function that can provide attributes for our users to select. And in the end, we found out that this checkbox could not provide us any further research insights, but since we have spent a lot of time dealing with the problem between checkbox, radio button, and slider, we still decided to keep it.<br><br>
        <h3>Number of Reviews v.s. Calculated Host Listings Count</h3>We used color to show the number of reviews on the map. The green dot means Airbnb with a low number of reviews, and the dark blue dot means Airbnb with a high number of reviews. We also used a radius to show the calculated host listings count. The dot with a bigger radius means the Airbnb has more hosting days this year, and the dot with smaller radius means the Airbnb has less host days this year.<br><br>It is intuitive to think that the number of reviews must have a direct correlation with calculated host listings count. Since the more hosting days you get, the number of reviews you will get. But it is surprising that these two parameters have few correlations with each other. In our opinion, there are two possibilities. First, we can not tell there are positive reviews or negative reviews from the number of reviews. Maybe people tend to be more willing to leave a review when they have negative feedback compared to positive feedback. And maybe people ignore the review and only consider the price, location, or other requirement they want when they choose the Airbnb. We could not know. Second, the data we can see here are the Airbnb with the last review time in 2019. It is possible that many new Airbnbs are emerging this year, so they would not have many reviews. If people like to give a chance to the newly open Airbnbs like me, this would increase the hosting days but would not necessarily increase the number of reviews.<br><br>  
         <h3>Locations v.s. Prices</h3>Before we analyzed price data, we found out that the price range is from 0 to 10,000. Then we realized that it is because of the minimum nights. Some of the Airbnb have the regulation that only host for a week or a month, which raises the price. After we make sure that all the price is per day, then we could start analysis the price data by using the brushable histogram combined with the map. First, we can tell that most of the prices fall between forty to two hundred dollars per day, by playing with the brushable histogram, we could check each price information on the above. Second, we can observe the location change while we set a different price ranges. The final insights could be listed in the following three points:  <br><br>
        <h4>1. When we filtered Airbnb with a price of over two hundred, Airbnb in Manhattan would be changed more than other regions.</h4>
        <h4>2. The location of Airbnb with a price below one hundred is distributed equally among five regions.</h4>
        <h4>3. The location of Airbnb with a price range from two hundred to three hundred is condensing on the south of Central Park in Manhattan. As we increase the price from three hundred to four hundred and four hundred to five hundred, this phenomenon becomes more obvious. </h4><br>
        <div style="float: left; padding-bottom: 50px"><img src="01.png" style="width: 480px"><img src="02.png" style="width: 480px"><img src="03.png" style="width: 480px"><img src="04.png" style="width: 480px"><img src="05.png" style="width: 480px"><img src="06.png" style="width: 480px"></div>
        <h1>Design</h1>
         <h2>Perceptual Principles</h2>For us, the most difficult questions for data visualization are how to make complex into simple? How to make our user focus? How to design the order for our user to notice? How to tell a good story? We think the key value of visualization design is “less.” Less is more. The most efficient way to convey an idea is to convey a simple idea at one time. This semester, what we have learned could help us making data visualization easy to understand, which is also our goal. Based on this notion, we only created one map with one chart and made them on one page. As a result of condensing so much information in only two charts, our next and greatest challenge is making all spacial data with the attributes meaningful but not overwhelming. We used shape, color, radius to represent different layers, number of reviews, and hosting days. We also used a checkbox, radio button, and slider to filter regions, room types, and years. Finally, we used a brushable histogram interacted with the map to show the relationship between price and location.<br><br>
         <h2>Visual Encoding</h2>Before our presentation, we stuck to the color from the Airbnb company identity system. After the presentation, we took the reference of color brewer and D3 scale chromatic and decided to move to the D3 scale chromatic. Because the colors in color brewer have high saturation, but the colors for the Airbnb company identity system are more like flat design colors, which are with lower saturation. Then we picked up a color system that could be in the spirit of Airbnb.<br><br>
        <h4>D3 scale chromatic</h4>
        <a href="https://github.com/d3/d3-scale-chromatic">https://github.com/d3/d3-scale-chromatic</a><br><br>
        <h4>Airbnb Colors</h4>
        <a href="https://usbrandcolors.com/airbnb-colors">https://usbrandcolors.com/airbnb-colors</a><br><br>
         <h2>Interactive Map</h2>We tried to move the subway line layer on the top of New York Map, but it did not work, so we make New York Map hollow. For the map legend, we used this resource to design the map legend:<br>
        <h4>d3 SVG Legend (v4)</h4>
        <a href="https://d3-legend.susielu.com">https://d3-legend.susielu.com</a><br><br>It is worth notice that this version is compatible with d3v4. In addition, we have to add the latest version of the d3-legend hosted on cdnjs, the d3 legend as a node module, and createClass via the main React package. I know nothing about cdn, npm, or react, and it is also my second time to run the terminal on the mac, so it took me some time to figure it out. It is so nice to have everything works finally.<br><br>
         <h2>Brushable Histogram</h2>At the very beginning of our project, we determined not to create many charts. We only work on the map interactive with the timeline bar chart. During our discussion with our instructor, we got feedback on changing the timeline bar chart into the price range and creating a brushable histogram.<br><br>
        <h2>Interaction</h2>The top challenge for us is undoubtedly the brushable function interacted with the map. Just like project 1, it is the final function that we could figure out before the deadline.<br><br>
        <h1>Summary</h1>
        We displayed 38,844 data and have used 11 attributes, including name, host name, neighborhood group, latitude, longitude, room type, price, minimum nights, number of reviews, last review, and calculated host listing count. The five attributes we did not use are id for name, id for host name, neighborhood, reviews per month, and availability 365.<br><br>
         <h1>Reflection</h1>Both of us are not a programmer, so we have to spend more time on this project than other groups. But everything is worth it. We have learned how to do the research online, how to manipulate the online resource and make it work, how to read the D3 and Javascript language, and how to deal with the simple coding problem. Even though we can not say that we know how to code, but we have learned how to use tools to analyze data, how to visualize data, what is the principle when designing data visualization, and how to make data visualization easy to understand, we feel that these skills are significantly useful and could benefit our future career in many aspects.<br><br> 
         <h4>Special thanks to Khairi Reda, Pony, Jun</h4>
    </div>
</body>
<script>
document.getElementById("input_year").value = 2019;
var slider = document.getElementById("input_year");
var output = document.getElementById("input_year-value");
output.innerHTML = slider.value;

slider.oninput = function() {
    output.innerHTML = this.value;
}

var w1 = 300,
    h1 = 50;

var key = d3.select("#legend1")
    .append("svg")
    .attr("width", w1)
    .attr("height", h1);

var legend = key.append("defs")
    .append("svg:linearGradient")
    .attr("id", "gradient")
    .attr("x1", "0%")
    .attr("y1", "100%")
    .attr("x2", "100%")
    .attr("y2", "100%")
    .attr("spreadMethod", "pad");

legend.append("stop")
    .attr("offset", "0%")
    .attr("stop-color", "#00A699")
    .attr("stop-opacity", 1);

legend.append("stop")
    .attr("offset", "100%")
    .attr("stop-color", "#084081")
    .attr("stop-opacity", 1);

key.append("rect")
    .attr("width", w1)
    .attr("height", h1 - 30)
    .style("fill", "url(#gradient)")
    .attr("transform", "translate(0,10)");

var y = d3.scaleLinear()
    .range([300, 0])
    .domain([629, 1]);

var yAxis = d3.axisBottom()
    .scale(y)
    .ticks(5);

key.append("g")
    .attr("class", "y axis")
    .attr("transform", "translate(0,30)")
    .call(yAxis)
    .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 0)
    .attr("dy", ".71em")
    .style("text-anchor", "end")

var w2 = 300,
    h2 = 50;

var key1 = d3.select("#legend2")
    .append("svg")
    .attr("width", w2)
    .attr("height", h2);

var linearSize = d3.scaleLinear().domain([1, 327]).range([1.01, 4.27]);

key1.append("g")
    .attr("class", "legendSize")
    .attr("transform", "translate(20, 10)");

var legendSize = d3.legendSize()
    .scale(linearSize)
    .shape('circle')
    .shapePadding(50)
    .labelOffset(20)
    .labelFormat(d3.format(".0f"))
    .orient('horizontal');

key1.select(".legendSize")
    .call(legendSize)

var w3 = 300,
    h3 = 60;

var key2 = d3.select("#legend3")
    .append("svg")
    .attr("width", w3)
    .attr("height", h3);

var triangleU = d3.symbol().type(d3.symbolTriangle)(),
    circle = d3.symbol().type(d3.symbolCircle)(),
    cross = d3.symbol().type(d3.symbolCross)(),
    diamond = d3.symbol().type(d3.symbolDiamond)(),
    star = d3.symbol().type(d3.symbolStar)();

//example output of d3.svg.symbol().type('circle')();
//"M0,4.51351666838205A4.51351666838205,4.51351666838205 0 1,1 0,
//-4.51351666838205A4.51351666838205,4.51351666838205 0 1,1 0,4.51351666838205Z"

var symbolScale = d3.scaleOrdinal()
    .domain(['Airbnb', 'Subway'])
    .range([circle, cross]);

key2.append("g")
    .attr("class", "legendSymbol")
    .attr("transform", "translate(50, 20)");

var legendPath = d3.legendSymbol()
    .scale(symbolScale)
    .orient("horizontal")
    .labelWrap(30)
    .shapePadding(50)
    .labelOffset(20)
    .on("cellclick", function(d) { alert("clicked " + d); });

key2.select(".legendSymbol")
    .call(legendPath);

var w = 680;
h = 660;

var svg1 = d3.select("#svg1")
    .style("width", w + "px")
    .style("height", h + "px")
    .attr("width", "100%")
    .attr("height", "100%")
    .call(d3.zoom().on("zoom", function() {
        svg1.attr("transform", d3.event.transform)
    }))
    .append("g")

var projection = d3.geoMercator()
    .center([-73.94, 40.70])
    .scale(80000)
    .translate([(w) / 2, (h) / 2]);

var path = d3.geoPath()
    .projection(projection);

var allCircles = svg1.selectAll("circle")

d3.json("nyc.json", function(error, nyb) {
    if (error) throw error;
    svg1.selectAll(".state")
        .data(nyb.features)
        .enter().append("path")
        .attr("class", function(d) { return d.properties.name; })
        .attr("d", path)
        .attr("stroke", "#767676")
        .attr("fill", "none")

});

d3.json("routes.json", function(routes) {
    svg1.selectAll(".path")
        .data(topojson.feature(routes, routes.objects.nyctsubwayroutes_100627).features)
        .enter().append("path")
        .attr("d", path)
        .attr("stroke", "#FC642D")
        .attr("fill", "none")

});

d3.csv("stops.csv", function(stops) {
    svg1.selectAll(".stop")
        .data(stops)
        .enter().append("rect")
        .attr("width", 5)
        .attr("height", 5)
        .attr("stroke", "none")
        .attr("fill", "#FC642D")
        .attr("x", function(d) { return projection([d.STOP_LON, d.STOP_LAT])[0] })
        .attr("y", function(d) { return projection([d.STOP_LON, d.STOP_LAT])[1] })

});

var points; //jun

d3.csv("AB_NYC_2019.csv", function(data_review) {
    points = data_review; //jun 
    function update_points(year) {
        svg1.selectAll("circle").remove()
        var y = document.getElementById("input_year").value;
        var choices = [];
        d3.selectAll(".checkbox").each(function(d, i) {
            cb = d3.select(this);
            grp = cb.property("value")
            if (cb.property("checked")) {
                choices.push(cb.property("value"));
                console.log(choices);

            }
        });

        var form = document.getElementById("room");
        var form_val;
        for (var i = 0; i < form.length; i++) {
            if (form[i].checked) {
                form_val = form[i].id;
            }
        }

        var colors = d3.scaleQuantize()
            .domain([1, 629])
            .range(["#00A699", "#084081"]);

        svg1.selectAll("circle")
            .data(data_review.filter(function(d) {
                return ((d.last_review == year | d.last_review == y) && (d.number_of_reviews >= 1 | d.calculated_host_listings_count >= 1) && d.room_type == form_val &&
                    (d.neighbourhood_group == choices[0] | d.neighbourhood_group == choices[1] | d.neighbourhood_group == choices[2] | d.neighbourhood_group == choices[3] | d.neighbourhood_group == choices[4]));
            }))
            .enter()
            .append("circle")
            .attr("class", function(d, i) { return d.neighbourhood_group })
            .attr("cx", function(d, i) { return projection([+d.longitude, +d.latitude])[0] })
            .attr("cy", function(d, i) { return projection([+d.longitude, +d.latitude])[1] })
            .attr("stroke", "none")
            .attr("fill", d => colors(d.number_of_reviews))
            .style("opacity", 0.5)
            .transition()
            .duration(1000)
            .ease(d3.easeCubic)
            .attr("r", function(d, i) {
                return 1 + (0.01 * (+d.calculated_host_listings_count));
            })


        svg1.selectAll("circle")
            .on("mouseover", function(d, i) {
                //this.parentNode.appendChild(this);//the path group is on the top with in its parent group

                d3.select(this).style('stroke', '#484848');
                d3.select(this).style("stroke-width", 1);
                d3.select(this).style("stroke-opacity", 1);
                d3.select(this).style("opacity", 1);

                //Get this bar's x/y values, then augment for the tooltip
                var xPosition = 0;
                var yPosition = 0;

                //Update the tooltip position and value
                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#name")
                    .text(d.name);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#host_name")
                    .text(d.host_name);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#neighbourhood_group")
                    .text(d.neighbourhood_group);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#room_type")
                    .text(d.room_type);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#price")
                    .text(d.price);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#minimum_nights")
                    .text(d.minimum_nights);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#number_of_reviews")
                    .text(d.number_of_reviews);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#review_time")
                    .text(d.review_time);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#calculated_host_listings_count")
                    .text(d.calculated_host_listings_count);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#availability_365")
                    .text(d.availability_365);

                //Show the tooltip
                d3.select("#tooltip").classed("hidden", false);


            })
            .on("mouseout", function() {
                d3.select(this).style("stroke", "none");
                //d3.select(this).style("stroke-width", 0.15);
                d3.select(this).style("opacity", 0.5);

            });
    }

    update_points(document.getElementById("input_year").value);

    d3.select("#input_year").on("input", function() {
        update_points(+this.value);
    });

    // When a button change, I run the update function
    d3.selectAll("input").on("change", update_points);

    // And I initialize it at the beginning
    update_points()

})



var zooming = function(d) {

    //Log out d3.event.transform, so you can see all the goodies inside
    //console.log(d3.event.transform);

    //New offset array
    var offset = [d3.event.transform.x, d3.event.transform.y];

    //Calculate new scale
    var newScale = d3.event.transform.k * 2000;

    //Update projection with new offset and scale
    projection.translate(offset)
        .scale(newScale);

    //Update all paths and circles
    svg1.selectAll("path")
        .attr("d", path);

    svg1.selectAll("circle")
        .attr("cx", function(d) {
            return projection([d.lon, d.lat])[0];
        })
        .attr("cy", function(d) {
            return projection([d.lon, d.lat])[1];
        });

    svg1.selectAll(".label")
        .attr("x", function(d) {
            return path.centroid(d)[0];
        })
        .attr("y", function(d) {
            return path.centroid(d)[1];
        });

};
</script>
<script>
//var parseTime = d3.timeParse("%Y-%m-%d");
//var mouseoverTime = d3.timeFormat("%a %e %b %Y");
//var minTime = d3.timeFormat("%b%e, %Y");
//var parseDate = d3.timeParse("%b %Y");
var rowConverter = function(d) {
    return {
        pricehigh: parseTime(d.pricehigh),
        price: parseInt(d.price)
    };
}
/* Adapted from: https://bl.ocks.org/mbostock/34f08d5e11952a80609169b7917d4172 */
d3.csv("price.csv", function(data) {


    var data;

    var margin = {
            top: 20,
            right: 20,
            bottom: 90,
            left: 50
        },
        margin2 = {
            top: 230,
            right: 20,
            bottom: 30,
            left: 50
        },
        width = 600 - margin.left - margin.right,
        height = 300 - margin.top - margin.bottom,
        height2 = 300 - margin2.top - margin2.bottom;

    //var parseTime = d3.timeParse("%Y-%m-%d");

    // var local = d3.local();

    var x = d3.scaleLinear().range([0, width]),
        x2 = d3.scaleLinear().range([0, width]),
        y = d3.scaleLinear().range([height, 0]),
        y2 = d3.scaleLinear().range([height2, 0]);
    // dur = d3.scaleLinear().range([0, 12]);

    //var xAxis = d3.axisBottom(x).tickSize(0);
    var xAxis2 = d3.axisBottom(x2).tickSize(0).ticks(20).tickFormat(data.pricehigh)

    yAxis = d3.axisLeft(y).tickSize(0);

    var xAxis = d3.axisBottom(x).ticks(20).tickFormat(data.pricehigh);


    var brush = d3.brushX()
        .extent([
            [0, 0],
            [width, height2]
        ])
        .on("start brush end", brushed);

    var zoom = d3.zoom()
        .scaleExtent([1, 10])
        .translateExtent([
            [0, 0],
            [width, height]
        ])
        .extent([
            [0, 0],
            [width, height]
        ])
        .on("zoom", zoomed);

    var svg2 = d3.select("#svg2")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

    svg2.append("defs").append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", height);

    var focus = svg2.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var context = svg2.append("g")
        .attr("class", "context")
        .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

    // d3.json("data.json", function(error, data) {
    // if (error) throw error;


    data.forEach(function(d) {
            d.pricehigh = +d.pricehigh;
            d.count = +d.count;
            return d;
        },
        function(error, data) {
            if (error) throw error;
        });

    var total = 0;

    data.forEach(function(d) {
        total = d.pricehigh + total;
    });

    var minPrice = d3.min(data, function(d) {
        return d.pricehigh;
    });

    var xMin = d3.min(data, function(d) {
        return d.pricehigh;
    });

    var yMax = d3.max(data, function(d) {
        return d.count;
    });

    x.domain([xMin, d3.max(data, function(d) {
        return d.pricehigh;
    })]);
    y.domain([0, yMax]);
    x2.domain(x.domain());
    y2.domain(y.domain());

    var rects = focus.append("g");
    rects.attr("clip-path", "url(#clip)");
    rects.selectAll("rects")
        .data(data)
        .enter().append("rect")
        .style("fill", function(d) {
            return "#FF5A5F";
        })
        .attr("class", "rects")
        .attr("x", function(d) {
            return x(d.pricehigh);
        })
        .attr("y", function(d) {
            return y(d.count);
        })
        .attr("width", function(d) {
            return 10;
        })
        .attr("height", function(d) {
            return height - y(d.count);
        });

    focus.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    focus.append("g")
        .attr("class", "axis axis--y")
        .call(yAxis);

    // Summary Stats
    focus.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left)
        .attr("x", 0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Total Counts");

    svg2.append("text")
        .attr("transform",
            "translate(" + ((width + margin.right + margin.left) / 2) + " ," +
            (height + margin.top + margin.bottom) + ")")
        .style("text-anchor", "middle")
        .text("Price Per Night in US dollars");

    svg2.append("rect")
        .attr("class", "zoom")
        .attr("width", width)
        .attr("height", height)
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .call(zoom);

    var rects = context.append("g");
    rects.attr("clip-path", "url(#clip)");
    rects.selectAll("rects")
        .data(data)
        .enter().append("rect")
        .style("fill", function(d) {
            return "#FF5A5F";
        })
        .attr("class", "rects")
        .attr("x", function(d) {
            return x2(d.pricehigh);
        })
        .attr("y", function(d) {
            return y2(d.count);
        })
        .attr("width", function(d) {
            return 10;
        })
        .attr("height", function(d) {
            return height2 - y2(d.count);
        });

    context.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);

    context.append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, x.range());

    // });

    function brushed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        var s = d3.event.selection || x2.range();
        x.domain(s.map(x2.invert, x2));
        focus.selectAll(".rects")
            .attr("x", function(d) {
                return x(d.pricehigh);
            })
            .attr("y", function(d) {
                return y(d.count);
            })
            .attr("width", function(d) {
                return 10;
            })
            .attr("height", function(d) {
                return height - y(d.count);
            });
        focus.select(".x-axis").call(xAxis);
        svg2.select(".zoom").call(zoom.transform, d3.zoomIdentity
            .scale(width / (s[1] - s[0]))
            .translate(-s[0], 0));
        var e = d3.event.selection;
        var selectedrects = focus.selectAll('.rects').filter(function() {
            var xValue = this.getAttribute('x');
            return e[0] <= xValue && xValue <= e[1];
        });

        //jun
        if (points) {
            update_points(document.getElementById("input_year").value, e);
        }
    }

    function zoomed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
        var t = d3.event.transform;
        x.domain(t.rescaleX(x2).domain());
        focus.selectAll(".rects")
            .attr("x", function(d) {
                return x(d.pricehigh);
            })
            .attr("y", function(d) {
                return y(d.count);
            })
            .attr("width", function(d) {
                return 10;
            })
            .attr("height", function(d) {
                return height - y(d.count);
            });

        focus.select(".x-axis").call(xAxis);
        context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
    }

    //jun 
    function update_points(year, price) {
        var colors = d3.scaleQuantize()
            .domain([1, 629])
            .range(["#00A699", "#084081"]);

        svg1.selectAll("circle").remove()
        var y = document.getElementById("input_year").value;
        var choices = [];
        d3.selectAll(".checkbox").each(function(d, i) {
            cb = d3.select(this);
            grp = cb.property("value")
            if (cb.property("checked")) {
                choices.push(cb.property("value"));
                console.log(choices);

            }
        });

        var form = document.getElementById("room");
        var form_val;
        for (var i = 0; i < form.length; i++) {
            if (form[i].checked) {
                form_val = form[i].id;
            }
        }

        var colors = d3.scaleQuantize()
            .domain([1, 629])
            .range(["#00A699", "#084081"]);

        svg1.selectAll("circle")
            .data(points.filter(function(d) {
                return ((price[0] <= d.price && d.price <= price[1]) && (d.last_review == year | d.last_review == y) && (d.number_of_reviews >= 1 | d.calculated_host_listings_count >= 1) && d.room_type == form_val &&
                    (d.neighbourhood_group == choices[0] | d.neighbourhood_group == choices[1] | d.neighbourhood_group == choices[2] | d.neighbourhood_group == choices[3] | d.neighbourhood_group == choices[4]));
            }))
            .enter()
            .append("circle")
            .attr("class", function(d, i) { return d.neighbourhood_group })
            .attr("cx", function(d, i) { return projection([+d.longitude, +d.latitude])[0] })
            .attr("cy", function(d, i) { return projection([+d.longitude, +d.latitude])[1] })
            .attr("stroke", "none")
            .attr("fill", d => colors(d.number_of_reviews))
            .style("opacity", 0.5)
            .transition()
            .duration(1000)
            .ease(d3.easeCubic)
            .attr("r", function(d, i) {
                return 1 + (0.01 * (+d.calculated_host_listings_count));
            })


        svg1.selectAll("circle")
            .on("mouseover", function(d, i) {
                //this.parentNode.appendChild(this);//the path group is on the top with in its parent group

                d3.select(this).style('stroke', '#484848');
                d3.select(this).style("stroke-width", 1);
                d3.select(this).style("stroke-opacity", 1);
                d3.select(this).style("opacity", 1);

                //Get this bar's x/y values, then augment for the tooltip
                var xPosition = 0;
                var yPosition = 0;

                //Update the tooltip position and value
                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#name")
                    .text(d.name);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#host_name")
                    .text(d.host_name);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#neighbourhood_group")
                    .text(d.neighbourhood_group);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#room_type")
                    .text(d.room_type);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#price")
                    .text(d.price);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#minimum_nights")
                    .text(d.minimum_nights);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#number_of_reviews")
                    .text(d.number_of_reviews);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#review_time")
                    .text(d.review_time);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#calculated_host_listings_count")
                    .text(d.calculated_host_listings_count);

                d3.select("#tooltip")
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px")
                    .select("#availability_365")
                    .text(d.availability_365);

                //Show the tooltip
                d3.select("#tooltip").classed("hidden", false);


            })
            .on("mouseout", function() {
                d3.select(this).style("stroke", "none");
                //d3.select(this).style("stroke-width", 0.15);
                d3.select(this).style("opacity", 0.5);

            });
    }
});
</script>

</html>